<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style> h1, h2, h3, .neon-chip { font-family:"Orbitron", ui-sans-serif, system-ui; } </style>
  <title>Perfect System · Tron UI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="./css/tron.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen" style="background-color: var(--tron-bg);">
  <div class="grid-bg"></div>

  <header class="max-w-7xl mx-auto px-6 pt-8 pb-4 flex items-start justify-between">
    <div>
      <h1 class="text-3xl md:text-4xl font-bold" style="color:#cfe9ff">Perfect System</h1>
      <p class="mt-1 text-sm md:text-base" style="color:#9db0c7">
        A tiny desired-state orchestrator: <span class="tooltip" title="You declare the target.">Desired</span> →
        <span class="tooltip" title="What is actually running right now.">Actual</span>.
        The Controller reconciles until they match.
      </p>
      <div class="mt-3 flex gap-2">
        <button id="playDemo" class="neon-btn" style="color:#031b1a;background:linear-gradient(90deg,#00ffc6,#00e1ff);">▶ Play Demo</button>
        <button id="tourBtn" class="neon-btn" style="color:#9bd5ff">What am I seeing?</button>
        <label class="inline-flex items-center gap-2 text-sm" style="color:#cfe9ff">
          <input id="explainToggle" type="checkbox" class="h-4 w-4" /> Explain mode
        </label>
      </div>
    </div>
    <div class="flex items-center gap-3">
      <span id="connDot" class="status-dot" style="color:#7a8fa6"></span>
      <span id="connText" class="text-sm" style="color:#9db0c7">Connecting…</span>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-6 pb-10 space-y-6">
    <!-- Actions -->
    <section class="grid md:grid-cols-3 gap-4">
      <div class="neon-border p-4">
        <div class="flex items-center justify-between">
          <h2 class="text-xl" style="color:#9bd5ff">Apply YAML</h2>
          <div class="flex gap-2">
            <button id="applyV1" class="neon-btn" style="color:#9bd5ff">v1</button>
            <button id="applyV2" class="neon-btn" style="color:#9bd5ff">v2</button>
            <button id="applyCanary" class="neon-btn" style="color:#9bd5ff">Canary</button>
          </div>
        </div>
        <textarea id="yamlInput" class="mt-3 w-full h-40 bg-[#081018] text-[#cfe9ff] p-3 rounded" placeholder="Paste YAML here…"></textarea>
        <div class="mt-2 flex gap-2">
          <button id="applyYamlBtn" class="neon-btn" style="color:#9bd5ff">Apply</button>
          <button id="copyCurl" class="neon-btn" style="color:#9bd5ff">Copy curl</button>
        </div>
        <div class="mt-2 flex gap-2">
          <button id="scaleDown" class="neon-btn" style="color:#9bd5ff">−1</button>
          <button id="scaleUp" class="neon-btn" style="color:#9bd5ff">+1</button>
        </div>
      </div>
      <div class="neon-border p-4">
        <h2 class="text-xl" style="color:#9bd5ff">Chaos</h2>
        <div class="mt-2 flex gap-2">
          <select id="chaosService" class="bg-[#0b1a24] text-[#cfe9ff] p-2 rounded">
            <option>api</option>
          </select>
          <button id="killOne" class="neon-btn" style="color:#ff9f43">Kill 1</button>
          <button id="killThree" class="neon-btn" style="color:#ff9f43">Kill 3</button>
        </div>
      </div>
      <div class="neon-border p-4">
        <h2 class="text-xl" style="color:#9bd5ff">Simulated Load</h2>
        <div class="mt-2 flex gap-2 items-center">
          <input id="cpuRange" type="range" min="0" max="100" value="0" class="w-full" />
          <span id="cpuVal" class="text-[#cfe9ff]">0%</span>
          <button id="applyLoad" class="neon-btn" style="color:#9bd5ff">Set</button>
        </div>
        <p class="text-xs mt-1" style="color:#7aa8c7">Autoscaler reacts if targetCPU is set (see examples).</p>
      </div>
    </section>

    <!-- Diff + Services -->
    <section class="grid md:grid-cols-2 gap-4">
      <div class="neon-border p-4">
        <h2 class="text-xl mb-2" style="color:#9bd5ff">Services (Desired vs Actual)</h2>
        <div id="services"></div>
      </div>
      <div class="neon-border p-4">
        <h2 class="text-xl mb-2" style="color:#9bd5ff">Pods</h2>
        <div id="pods" class="grid sm:grid-cols-2 gap-2"></div>
      </div>
    </section>

    <!-- Metrics Dashboard -->
    <section class="neon-border p-4">
      <h2 class="text-xl mb-2" style="color:#9bd5ff">Metrics Dashboard</h2>
      <div id="metricsGrid" class="grid sm:grid-cols-2 md:grid-cols-4 gap-3">
        <!-- Populated by JavaScript -->
      </div>
    </section>

    <!-- Graphs -->
    <section class="neon-border p-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl" style="color:#9bd5ff">Graphs</h2>
        <div class="flex gap-2 items-center">
          <span class="text-sm" style="color:#cfe9ff">Service</span>
          <select id="graphService" class="bg-[#0b1a24] text-[#cfe9ff] p-2 rounded"></select>
          <button id="clearGraphs" class="neon-btn" style="color:#9bd5ff">Clear</button>
        </div>
      </div>
      <p class="text-xs mt-1" style="color:#7aa8c7">Live charts built from the stream of reconciler state (last ~2 minutes).</p>
      <div class="grid md:grid-cols-3 gap-3 mt-3">
        <div class="chart-card">
          <div class="chart-title">Ready vs Desired</div>
          <canvas id="chartReady" class="chart-canvas"></canvas>
          <div class="chart-foot">How quickly the controller converges to Desired replicas.</div>
        </div>
        <div class="chart-card">
          <div class="chart-title">Warn/Error events per minute</div>
          <canvas id="chartRestarts" class="chart-canvas"></canvas>
          <div class="chart-foot">Rolling count of WARN/ERROR events in the last 60 seconds (health, rollouts, scaling, chaos).</div>
        </div>
        <div class="chart-card">
          <div class="chart-title">CPU load</div>
          <canvas id="chartCpu" class="chart-canvas"></canvas>
          <div class="chart-foot">Simulated CPU used by the tiny HPA controller.</div>
        </div>
      </div>
    </section>

    <!-- Events -->
    <section class="neon-border p-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl" style="color:#9bd5ff">Events</h2>
        <div class="flex gap-2">
          <select id="evtFilter" class="bg-[#0b1a24] text-[#cfe9ff] p-1 rounded">
            <option value="">All</option>
            <option>rollout</option>
            <option>health</option>
            <option>scaling</option>
            <option>chaos</option>
          </select>
          <label class="inline-flex items-center gap-2 text-sm" style="color:#cfe9ff">
            <input id="autoRefresh" type="checkbox" class="h-4 w-4" checked /> Auto refresh
          </label>
        </div>
      </div>
      <div id="events" class="mt-2 max-h-72 overflow-auto"></div>
    </section>
  </main>

  <!-- Help modal -->
  <div id="helpModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal-body neon-border">
      <h2 id="helpTitle" class="text-2xl" style="color:#9bd5ff">Perfect System (Tron)</h2>
      <p class="mt-2 text-sm" style="color:#cfe9ff">Declare <b>Desired</b>. The Controller reconciles <b>Actual</b> until they match.</p>
      <ul class="list-disc pl-5 text-sm mt-2" style="color:#9bd5ff">
        <li><b>Apply YAML:</b> sets Desired.</li>
        <li><b>Services/Pods:</b> shows Actual.</li>
        <li><b>Events:</b> tells you what happened (rollouts, health, scaling, chaos).</li>
        <li><b>Try this:</b> Play Demo (v1 → v2 → chaos).</li>
      </ul>
      <div class="mt-3 flex gap-2">
        <button id="playDemo2" class="neon-btn" style="color:#031b1a;background:linear-gradient(90deg,#00ffc6,#00e1ff);">▶ Play Demo</button>
        <button id="closeHelp" class="neon-btn" style="color:#9bd5ff">Close</button>
      </div>
    </div>
  </div>

<script>
const $ = (id)=>document.getElementById(id);
const connDot = $('connDot'); const connText = $('connText');
const yamlInput = $('yamlInput'); const servicesDiv=$('services'); const podsDiv=$('pods'); const eventsDiv=$('events');
const autoRefresh = $('autoRefresh'); const tourBtn=$('tourBtn'); const helpModal=$('helpModal');
const explainToggle=$('explainToggle'); const cpuRange=$('cpuRange'); const cpuVal=$('cpuVal');

const graphServiceSel = $('graphService');
const clearGraphsBtn = $('clearGraphs');
const chartReady = $('chartReady');
const chartRestarts = $('chartRestarts');
const chartCpu = $('chartCpu');

// Graph history: keep a short window of time series in the browser.
const GRAPH_RANGE_MS = 2 * 60 * 1000; // ~2 minutes
const graphHistory = {
  ready: {},
  desired: {},
  anoms: {},
  restarts: {},
  cpu: {},
};

// For a *real* "per minute" anomalies graph we keep a local buffer of WARN/ERROR
// event timestamps and compute a rolling 60s count.
const anomEventBuffer = {}; // svc -> [tsMs,...]
const anomSeenKeys = new Set();
const anomSeenQueue = []; // FIFO to cap memory
const MAX_SEEN_EVENT_KEYS = 5000;
let selectedGraphSvc = 'api';

let V1 = `apiVersion: v1
kind: Service
metadata: { name: api }
spec:
  image: local://demo@v1
  replicas: 3
  env:
    - { name: HEALTHY, value: "1" }
  readinessProbe:
    httpGet: { path: /healthz }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  livenessProbe:
    httpGet: { path: /livez }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  rollout:
    strategy: BlueGreen
`;
let V2 = `apiVersion: v1
kind: Service
metadata: { name: api }
spec:
  image: local://demo@v2
  replicas: 3
  env:
    - { name: HEALTHY, value: "1" }
  readinessProbe:
    httpGet: { path: /healthz }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  livenessProbe:
    httpGet: { path: /livez }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  rollout:
    strategy: BlueGreen
`;
let CAN = `apiVersion: v1
kind: Service
metadata: { name: api }
spec:
  image: local://demo@v2
  replicas: 4
  env:
    - { name: HEALTHY, value: "1" }
  readinessProbe:
    httpGet: { path: /healthz }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  livenessProbe:
    httpGet: { path: /livez }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  rollout:
    strategy: Canary
    steps:
      - { percent: 25 }
      - { percent: 50 }
      - { percent: 100 }
    pauseSeconds: 5
`;

yamlInput.value = V1;

cpuRange.addEventListener('input', ()=> cpuVal.textContent = cpuRange.value + '%');

function playClick(){ /* optional sfx; placeholder */ }

function row(html){ const d=document.createElement('div'); d.innerHTML=html; return d.firstElementChild; }

function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function pushPoint(map, svc, t, v){
  map[svc] = map[svc] || [];
  const arr = map[svc];
  arr.push({ t, v });
  // Trim to time window (+ buffer)
  const cutoff = t - (GRAPH_RANGE_MS + 10_000);
  while (arr.length && arr[0].t < cutoff) arr.shift();
}

function recordAnomalyEvents(state){
  const evs = state?.events || [];
  for (const e of evs) {
    if (!e || !e.svc) continue;
    if (!(e.level === 'WARN' || e.level === 'ERROR')) continue;

    const tsMs = (typeof e.ts === 'number') ? e.ts : Date.parse(e.ts);
    if (!Number.isFinite(tsMs)) continue;

    // Best-effort de-dupe key (events don't have stable IDs in this project).
    const key = `${tsMs}|${e.level}|${e.svc}|${e.pod || ''}|${e.msg || ''}`;
    if (anomSeenKeys.has(key)) continue;
    anomSeenKeys.add(key);
    anomSeenQueue.push(key);
    if (anomSeenQueue.length > MAX_SEEN_EVENT_KEYS) {
      const old = anomSeenQueue.shift();
      if (old) anomSeenKeys.delete(old);
    }

    (anomEventBuffer[e.svc] = anomEventBuffer[e.svc] || []).push(tsMs);
  }

  // Prune buffers so they don't grow forever.
  const cutoff = Date.now() - (GRAPH_RANGE_MS + 60_000 + 10_000);
  for (const [svc, arr] of Object.entries(anomEventBuffer)) {
    while (arr.length && arr[0] < cutoff) arr.shift();
    if (!arr.length) delete anomEventBuffer[svc];
  }
}

function updateGraphServiceOptions(state){
  const names = Object.keys(state.services || {});
  if (!names.length) return;
  // If current selection disappeared, pick the first.
  if (!names.includes(selectedGraphSvc)) selectedGraphSvc = names[0];
  const cur = selectedGraphSvc;
  graphServiceSel.innerHTML = '';
  for (const n of names) {
    const opt = document.createElement('option');
    opt.value = n; opt.textContent = n;
    if (n === cur) opt.selected = true;
    graphServiceSel.appendChild(opt);
  }
}

function updateGraphHistory(state){
  const t = Date.now();
  recordAnomalyEvents(state);
  for (const [name, svc] of Object.entries(state.services || {})) {
    const desired = svc.replicas ?? 0;
    const ready = Object.values(state.pods || {}).filter(p=>p.service===name && p.ready).length;
    const restarts = (state.metrics?.restarts?.[name]) || 0;
    const cpu = svc.cpu || 0;

    // Anomalies / minute = rolling count of WARN/ERROR events observed in the last 60 seconds.
    const buf = anomEventBuffer[name] || [];
    const windowStart = t - 60_000;
    let anoms = 0;
    for (let i = buf.length - 1; i >= 0; i--) {
      if (buf[i] >= windowStart) anoms++;
      else break; // timestamps are appended in time order
    }

    pushPoint(graphHistory.desired, name, t, desired);
    pushPoint(graphHistory.ready, name, t, ready);
    pushPoint(graphHistory.anoms, name, t, anoms);
    pushPoint(graphHistory.restarts, name, t, restarts);
    pushPoint(graphHistory.cpu, name, t, cpu);
  }
}

function canvasBox(cnv){
  const ctx = cnv.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = cnv.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width));
  const h = Math.max(10, Math.floor(rect.height));
  if (cnv.width !== w * dpr || cnv.height !== h * dpr) {
    cnv.width = w * dpr;
    cnv.height = h * dpr;
  }
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, w, h };
}

function drawGrid(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = cssVar('--tron-grid') || 'rgba(0,255,255,0.08)';
  ctx.lineWidth = 1;
  const step = 40;
  for (let x=0; x<=w; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for (let y=0; y<=h; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.globalAlpha = 1;
}

function drawLine(ctx, points, xOf, yOf, stroke, dashed=false){
  if (!points || points.length < 2) return;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.setLineDash(dashed ? [6,4] : []);
  ctx.beginPath();
  for (let i=0;i<points.length;i++){
    const x = xOf(points[i]);
    const y = yOf(points[i]);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawText(ctx, txt, x, y, color){
  ctx.fillStyle = color;
  ctx.font = '12px Orbitron, ui-sans-serif, system-ui';
  ctx.fillText(txt, x, y);
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function drawTimeSeriesChart(cnv, seriesA, seriesB, opts){
  const { ctx, w, h } = canvasBox(cnv);
  drawGrid(ctx, w, h);

  const padL = 34, padR = 10, padT = 14, padB = 20;
  const left = padL, top = padT, right = w - padR, bottom = h - padB;

  const nowT = Date.now();
  const startT = nowT - GRAPH_RANGE_MS;
  const xOf = (p)=> left + ((p.t - startT) / GRAPH_RANGE_MS) * (right - left);

  const all = ([]).concat(seriesA||[], seriesB||[]).filter(p=>p.t >= startT);
  const vals = all.map(p=>p.v);
  let yMax = opts?.yMax != null ? opts.yMax : (Math.max(1, ...vals, 1));
  if (opts?.yMax == null) yMax = Math.max(1, Math.ceil(yMax * 1.25));
  const yOf = (p)=> bottom - (clamp(p.v, 0, yMax) / yMax) * (bottom - top);

  // Axis labels (0 and yMax)
  ctx.fillStyle = '#9db0c7';
  ctx.font = '10px ui-sans-serif, system-ui';
  ctx.fillText(String(yMax), 6, top+8);
  ctx.fillText('0', 14, bottom);
  ctx.globalAlpha = 0.6;
  ctx.strokeStyle = 'rgba(155,213,255,0.25)';
  ctx.beginPath(); ctx.moveTo(left, top); ctx.lineTo(left, bottom); ctx.lineTo(right, bottom); ctx.stroke();
  ctx.globalAlpha = 1;

  const good = cssVar('--tron-good') || '#00ff9d';
  const light = cssVar('--tron-light') || '#61e2ff';
  const warn = cssVar('--tron-warn') || '#ff9f43';

  drawLine(ctx, (seriesA||[]).filter(p=>p.t>=startT), xOf, yOf, opts?.colorA || good, false);
  if (seriesB) drawLine(ctx, (seriesB||[]).filter(p=>p.t>=startT), xOf, yOf, opts?.colorB || light, true);

  // Legend
  if (opts?.labelA) drawText(ctx, opts.labelA, left + 6, 12, opts?.colorA || good);
  if (opts?.labelB) drawText(ctx, opts.labelB, left + 120, 12, opts?.colorB || light);

  // Latest value
  const lastA = (seriesA||[]).slice(-1)[0];
  if (lastA) {
    const t = `${opts?.valuePrefix||''}${lastA.v}${opts?.valueSuffix||''}`;
    drawText(ctx, t, right - 70, 12, opts?.valueColor || warn);
  }
}

function computeRatePerMinuteFromCumulative(cumulativeSeries){
  const pts = cumulativeSeries || [];
  if (pts.length < 2) return [];
  const out = [];
  for (let i=1;i<pts.length;i++){
    const a = pts[i-1], b = pts[i];
    const dt = Math.max(0.001, (b.t - a.t) / 1000);
    const dv = Math.max(0, (b.v - a.v));
    const perMin = (dv / dt) * 60;
    out.push({ t: b.t, v: perMin });
  }
  return out;
}

function renderGraphs(){
  const svc = selectedGraphSvc;
  const ready = graphHistory.ready[svc] || [];
  const desired = graphHistory.desired[svc] || [];
  const anoms = graphHistory.anoms[svc] || [];
  const restarts = graphHistory.restarts[svc] || [];
  const cpu = graphHistory.cpu[svc] || [];

  drawTimeSeriesChart(chartReady, ready, desired, {
    labelA: 'Ready',
    labelB: 'Desired',
    valuePrefix: '',
  });

  drawTimeSeriesChart(chartRestarts, anoms, null, {
    labelA: 'WARN+ERROR/min',
    yMax: Math.max(1, Math.ceil(Math.max(1, ...(anoms.map(p=>p.v)||[1])) * 1.25)),
    valueSuffix: '/m',
  });

  drawTimeSeriesChart(chartCpu, cpu, null, {
    labelA: 'CPU %',
    yMax: 100,
    valueSuffix: '%',
  });
}

function render(state){
  // conn status
  connDot.style.color = '#00ff9d'; connText.textContent='Live';
  // services diff
  servicesDiv.innerHTML='';
  for (const [name, svc] of Object.entries(state.services)){
    const ready = Object.values(state.pods).filter(p=>p.service===name && p.ready).length;
    const desired = svc.replicas;
    const digestActual = (Object.values(state.pods).find(p=>p.service===name)?.image_digest)||'(none)';
    const diffHTML = `<div class="p-3 rounded border border-[#1b3a48] mb-2">
      <div class="flex items-center justify-between">
        <div class="text-[#cfe9ff]"><b>${name}</b></div>
        <div class="text-sm"><span style="color:#9bd5ff">Desired</span>: ${desired} · ${svc.digest} | <span style="color:#9bd5ff">Actual</span>: ${ready} · ${digestActual}</div>
      </div>
      <div class="mt-1 h-2 bg-[#0b1a24] rounded overflow-hidden">
        <div style="width:${Math.min(100, (ready/Math.max(1,desired))*100)}%; background:#00ff9d; height:100%"></div>
      </div>
    </div>`;
    servicesDiv.appendChild(row(diffHTML));
  }
  // pods
  podsDiv.innerHTML='';
  const pods = Object.values(state.pods).sort((a,b)=>a.start_ts-b.start_ts);
  for (const p of pods){
    const clr = p.ready ? '#00ff9d' : '#ff5c7a';
    podsDiv.appendChild(row(`<div class="p-3 rounded border border-[#1b3a48]">
      <div class="flex items-center justify-between">
        <div class="text-[#cfe9ff]"><b>${p.service}</b> · <span style="color:${clr}">${p.ready?'Ready':'NotReady'}</span></div>
        <div class="text-xs" style="color:#9bd5ff">digest ${p.image_digest} · ${p.id.slice(0,6)}</div>
      </div>
      <div class="text-xs mt-1" style="color:#7aa8c7">port ${p.port} · restarts ${p.restarts||0}</div>
    </div>`));
  }
  // events
  const filt = $('evtFilter').value;
  eventsDiv.innerHTML='';
  const evs = state.events.slice(-200).reverse();
  for (const e of evs){
    if (filt && !(e.msg.toLowerCase().includes(filt) || (e.explain||'').toLowerCase().includes(filt))) continue;
    const when = new Date(e.ts).toLocaleTimeString();
    const explain = (state.explain || $('explainToggle').checked) && e.explain ? ` — <span style="color:#9bd5ff">${e.explain}</span>` : '';
    eventsDiv.appendChild(row(`<div class="text-sm py-1 border-b border-[#142833]" style="color:#cfe9ff">
      <span style="color:#7aa8c7">${when}</span> [${e.level}] ${e.svc||'-'} ${e.pod||''}: ${e.msg}${explain}
    </div>`));
  }
  
  // Render metrics
  renderMetrics();

  // Graphs
  updateGraphServiceOptions(state);
  updateGraphHistory(state);
  renderGraphs();
}

async function renderMetrics() {
  try {
    const resp = await fetch('/metrics', { headers: {'Accept': 'text/plain'} });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    console.log('[DEBUG] Metrics raw:', text.slice(0, 200)); // First 200 chars
    
    const metrics = parseMetrics(text);
    console.log('[DEBUG] Parsed metrics:', metrics);
    
    const metricsGrid = $('metricsGrid');
    metricsGrid.innerHTML = '';
    
    // Ready pods gauge
    const podsReady = metrics['api_pods_ready{service="api"}'] || 0;
    const podsDesired = metrics['api_pods_desired{service="api"}'] || 1;
    const readyPct = Math.round((podsReady / Math.max(1, podsDesired)) * 100);
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Ready Pods</div>
        <div class="gauge-value">${podsReady}/${podsDesired}</div>
        <div class="gauge-bar"><div class="gauge-fill" style="width: ${readyPct}%"></div></div>
        <div class="text-xs" style="color:#9bd5ff; margin-top: 4px;">${readyPct}%</div>
      </div>
    `));
    
    // Total restarts gauge
    const restarts = metrics['api_restarts_total{service="api"}'] || 0;
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Total Restarts</div>
        <div class="gauge-value">${restarts}</div>
        <div class="text-xs" style="color:#9db0c7; margin-top: 6px;">since start</div>
      </div>
    `));
    
    // INFO events counter
    const infoEvents = metrics['api_events_total{service="api",level="INFO"}'] || 0;
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Info Events</div>
        <div class="gauge-value">${infoEvents}</div>
        <div class="text-xs" style="color:#9db0c7; margin-top: 6px;">lifecycle</div>
      </div>
    `));
    
    // WARN events counter
    const warnEvents = metrics['api_events_total{service="api",level="WARN"}'] || 0;
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Warn Events</div>
        <div class="gauge-value" style="color: #ff9f43;">${warnEvents}</div>
        <div class="text-xs" style="color:#9db0c7; margin-top: 6px;">anomalies</div>
      </div>
    `));
    
    console.log('[SUCCESS] Metrics rendered');
  } catch (e) {
    console.error('Metrics fetch failed:', e);
  }
}

function parseMetrics(text) {
  const lines = text.split('\n');
  const metrics = {};
  
  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    
    // Parse: api_pods_ready{service="api"} 3
    const match = line.match(/^([\w_]+(?:\{[^}]+\})?)\s+([\d.]+)$/);
    if (match) {
      const [, key, value] = match;
      metrics[key] = parseFloat(value);
    }
  }
  
  return metrics;
}

graphServiceSel.addEventListener('change', ()=>{
  selectedGraphSvc = graphServiceSel.value;
  renderGraphs();
});
clearGraphsBtn.addEventListener('click', ()=>{
  for (const k of Object.keys(graphHistory)) graphHistory[k] = {};
  for (const k of Object.keys(anomEventBuffer)) delete anomEventBuffer[k];
  anomSeenKeys.clear();
  anomSeenQueue.length = 0;
  renderGraphs();
});
window.addEventListener('resize', ()=> renderGraphs());

async function fetchState(){ const r = await fetch('/state'); const s = await r.json(); render(s); }

// SSE live updates (best effort)
try {
  const es = new EventSource('/events');
  es.onmessage = (ev)=> { const s = JSON.parse(ev.data); render(s); };
  es.onerror = ()=> { connDot.style.color='#7a8fa6'; connText.textContent='Disconnected'; };
} catch{}

async function applyYaml(y){ await fetch('/apply', { method:'POST', headers:{'Content-Type':'application/yaml'}, body:y }); playClick(); }
async function kill(service, count){ await fetch('/chaos/kill?service='+encodeURIComponent(service)+'&count='+count, { method:'POST' }); playClick(); }
async function scale(service, delta){ await fetch('/scale?service='+encodeURIComponent(service)+'&delta='+delta, { method:'POST' }); playClick(); }
async function setLoad(service, cpu){ await fetch('/load?service='+encodeURIComponent(service)+'&cpu='+cpu, { method:'POST' }); }

$('applyV1').onclick = ()=> applyYaml(V1);
$('applyV2').onclick = ()=> applyYaml(V2);
$('applyCanary').onclick = ()=> applyYaml(CAN);
$('applyYamlBtn').onclick = ()=> applyYaml(yamlInput.value);
$('scaleDown').onclick = ()=> scale('api', -1);
$('scaleUp').onclick = ()=> scale('api', 1);
$('copyCurl').onclick = ()=> {
  const cmd = `curl -X POST http://localhost:8080/apply -H 'Content-Type: application/yaml' --data-binary @- <<'YAML'\n${yamlInput.value}\nYAML`;
  navigator.clipboard.writeText(cmd);
};
document.addEventListener('keydown', (e)=> e.key==='y' && yamlInput.focus());

$('killOne').onclick = ()=> kill($('chaosService').value, 1);
$('killThree').onclick = ()=> kill($('chaosService').value, 3);
$('applyLoad').onclick = ()=> setLoad('api', parseInt(cpuRange.value,10));

// Guided tour
tourBtn.onclick = ()=> helpModal.classList.remove('hidden');
$('closeHelp').onclick = ()=> helpModal.classList.add('hidden');
$('playDemo2').onclick = ()=> playSequence();

$('playDemo').onclick = ()=> playSequence();
async function playSequence(){
  helpModal.classList.add('hidden');
  await applyYaml(V1);
  await sleep(3000);
  await applyYaml(V2);
  await sleep(4000);
  await applyYaml(CAN);
  await sleep(4000);
  await kill('api', 1);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// polling
let timer = null;
autoRefresh.addEventListener('change', () => {
  if (autoRefresh.checked) timer = setInterval(fetchState, 1500);
  else { clearInterval(timer); timer = null; }
});
fetchState();
if (autoRefresh.checked) timer = setInterval(fetchState, 1500);
</script>
</body>
</html>
