<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style> 
    h1, h2, h3, .neon-chip { font-family:"Orbitron", ui-sans-serif, system-ui; }
    
    .tab-btn {
      padding: 0.75rem 1.5rem;
      border: 1px solid rgba(155,213,255,0.3);
      background: transparent;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 4px;
    }
    
    .tab-btn:hover {
      background: rgba(155,213,255,0.1);
      border-color: rgba(155,213,255,0.5);
    }
    
    .tab-btn.active {
      background: rgba(155,213,255,0.1);
      border-color: #9bd5ff;
      box-shadow: 0 0 10px rgba(155,213,255,0.3);
    }
    
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 5px rgba(0,255,198,0.3); }
      50% { box-shadow: 0 0 15px rgba(0,255,198,0.6); }
    }
    
    .selected-pod {
      animation: pulse-glow 2s ease-in-out infinite;
    }
  </style>
  <title>Perfect System · Tron UI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="./css/tron.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen" style="background-color: var(--tron-bg);">
  <div class="grid-bg"></div>

  <header class="max-w-7xl mx-auto px-6 pt-8 pb-4 flex items-start justify-between">
    <div>
      <h1 class="text-3xl md:text-4xl font-bold" style="color:#cfe9ff">Perfect System</h1>
      <p class="mt-1 text-sm md:text-base" style="color:#9db0c7">
        A tiny desired-state orchestrator: <span class="tooltip" title="You declare the target.">Desired</span> →
        <span class="tooltip" title="What is actually running right now.">Actual</span>.
        The Controller reconciles until they match.
      </p>
      <div class="mt-3 flex gap-2">
        <button id="playDemo" class="neon-btn" style="color:#031b1a;background:linear-gradient(90deg,#00ffc6,#00e1ff);">▶ Play Demo</button>
        <button id="tourBtn" class="neon-btn" style="color:#9bd5ff">What am I seeing?</button>
        <label class="inline-flex items-center gap-2 text-sm" style="color:#cfe9ff">
          <input id="explainToggle" type="checkbox" class="h-4 w-4" /> Explain mode
        </label>
      </div>
    </div>
    <div class="flex items-center gap-3">
      <span id="connDot" class="status-dot" style="color:#7a8fa6"></span>
      <span id="connText" class="text-sm" style="color:#9db0c7">Connecting…</span>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-6 pb-10 space-y-6">
    <!-- Tab Navigation -->
    <section class="neon-border p-1">
      <div class="flex gap-2">
        <button id="tabMain" class="tab-btn active" style="color:#9bd5ff; background:rgba(155,213,255,0.1);">Main Dashboard</button>
        <button id="tabLoadBalancer" class="tab-btn" style="color:#9bd5ff;">Load Balancer</button>
      </div>
    </section>

    <!-- Main Dashboard Content -->
    <div id="mainDashboardContent">
    <!-- Actions -->
    <section class="grid md:grid-cols-3 gap-4">
      <div class="neon-border p-4">
        <div class="flex items-center justify-between">
          <h2 class="text-xl" style="color:#9bd5ff">Apply YAML</h2>
          <div class="flex gap-2">
            <button id="applyV1" class="neon-btn" style="color:#9bd5ff">v1</button>
            <button id="applyV2" class="neon-btn" style="color:#9bd5ff">v2</button>
            <button id="applyCanary" class="neon-btn" style="color:#9bd5ff">Canary</button>
          </div>
        </div>
        <textarea id="yamlInput" class="mt-3 w-full h-40 bg-[#081018] text-[#cfe9ff] p-3 rounded" placeholder="Paste YAML here…"></textarea>
        <div class="mt-2 flex gap-2">
          <button id="applyYamlBtn" class="neon-btn" style="color:#9bd5ff">Apply</button>
          <button id="copyCurl" class="neon-btn" style="color:#9bd5ff">Copy curl</button>
        </div>
        <div class="mt-2 flex gap-2">
          <button id="scaleDown" class="neon-btn" style="color:#9bd5ff">−1</button>
          <button id="scaleUp" class="neon-btn" style="color:#9bd5ff">+1</button>
        </div>
      </div>
      <div class="neon-border p-4">
        <h2 class="text-xl" style="color:#9bd5ff">Chaos</h2>
        <div class="mt-2 flex gap-2">
          <select id="chaosService" class="bg-[#0b1a24] text-[#cfe9ff] p-2 rounded">
            <option>api</option>
          </select>
          <button id="killOne" class="neon-btn" style="color:#ff9f43">Kill 1</button>
          <button id="killThree" class="neon-btn" style="color:#ff9f43">Kill 3</button>
        </div>
      </div>
      <div class="neon-border p-4">
        <h2 class="text-xl" style="color:#9bd5ff">Simulated Load</h2>
        <div class="mt-2 flex gap-2 items-center">
          <input id="cpuRange" type="range" min="0" max="100" value="0" class="w-full" />
          <span id="cpuVal" class="text-[#cfe9ff]">0%</span>
          <button id="applyLoad" class="neon-btn" style="color:#9bd5ff">Set</button>
        </div>
        <p class="text-xs mt-1" style="color:#7aa8c7">Autoscaler reacts if targetCPU is set (see examples).</p>
      </div>
    </section>

    <!-- Diff + Services -->
    <section class="grid md:grid-cols-2 gap-4">
      <div class="neon-border p-4">
        <h2 class="text-xl mb-2" style="color:#9bd5ff">Services (Desired vs Actual)</h2>
        <div id="services"></div>
      </div>
      <div class="neon-border p-4">
        <h2 class="text-xl mb-2" style="color:#9bd5ff">Pods</h2>
        <div id="pods" class="grid sm:grid-cols-2 gap-2"></div>
      </div>
    </section>

    <!-- Metrics Dashboard -->
    <section class="neon-border p-4">
      <h2 class="text-xl mb-2" style="color:#9bd5ff">Metrics Dashboard</h2>
      <div id="metricsGrid" class="grid sm:grid-cols-2 md:grid-cols-4 gap-3">
        <!-- Populated by JavaScript -->
      </div>
    </section>

    <!-- Graphs -->
    <section class="neon-border p-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl" style="color:#9bd5ff">Graphs</h2>
        <div class="flex gap-2 items-center">
          <span class="text-sm" style="color:#cfe9ff">Service</span>
          <select id="graphService" class="bg-[#0b1a24] text-[#cfe9ff] p-2 rounded"></select>
          <button id="clearGraphs" class="neon-btn" style="color:#9bd5ff">Clear</button>
        </div>
      </div>
      <p class="text-xs mt-1" style="color:#7aa8c7">Live charts built from the stream of reconciler state (last ~2 minutes).</p>
      <div class="grid md:grid-cols-3 gap-3 mt-3">
        <div class="chart-card">
          <div class="chart-title">Ready vs Desired</div>
          <canvas id="chartReady" class="chart-canvas"></canvas>
          <div class="chart-foot">How quickly the controller converges to Desired replicas.</div>
        </div>
        <div class="chart-card">
          <div class="chart-title">Warn/Error events per minute</div>
          <canvas id="chartRestarts" class="chart-canvas"></canvas>
          <div class="chart-foot">Rolling count of WARN/ERROR events in the last 60 seconds (health, rollouts, scaling, chaos).</div>
        </div>
        <div class="chart-card">
          <div class="chart-title">CPU load</div>
          <canvas id="chartCpu" class="chart-canvas"></canvas>
          <div class="chart-foot">Simulated CPU used by the tiny HPA controller.</div>
        </div>
      </div>
    </section>

    <!-- Events -->
    <section class="neon-border p-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl" style="color:#9bd5ff">Events</h2>
        <div class="flex gap-2">
          <select id="evtFilter" class="bg-[#0b1a24] text-[#cfe9ff] p-1 rounded">
            <option value="">All</option>
            <option>rollout</option>
            <option>health</option>
            <option>scaling</option>
            <option>chaos</option>
          </select>
          <label class="inline-flex items-center gap-2 text-sm" style="color:#cfe9ff">
            <input id="autoRefresh" type="checkbox" class="h-4 w-4" checked /> Auto refresh
          </label>
        </div>
      </div>
      <div id="events" class="mt-2 max-h-72 overflow-auto"></div>
    </section>
    </div>

    <!-- Load Balancer Dashboard Content -->
    <div id="loadBalancerContent" class="hidden">
      <!-- Controls -->
      <section class="neon-border p-4">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl" style="color:#9bd5ff">Load Balancer Controls</h2>
          <div class="flex gap-2">
            <select id="lbService" class="bg-[#0b1a24] text-[#cfe9ff] p-2 rounded">
              <option>api</option>
            </select>
            <button id="lbTestRequest" class="neon-btn" style="color:#00ffc6">Test Request</button>
            <button id="lbAutoTest" class="neon-btn" style="color:#9bd5ff">Auto Test (10x)</button>
            <button id="lbClearHistory" class="neon-btn" style="color:#ff9f43">Clear History</button>
          </div>
        </div>
      </section>

      <!-- Statistics Panel -->
      <section class="neon-border p-4">
        <h2 class="text-xl mb-3" style="color:#9bd5ff">Load Balance Statistics</h2>
        <div id="lbStats" class="grid sm:grid-cols-2 md:grid-cols-4 gap-3">
          <!-- Populated by JavaScript -->
        </div>
      </section>

      <!-- Round-Robin Visualization -->
      <section class="neon-border p-4">
        <h2 class="text-xl mb-3" style="color:#9bd5ff">Round-Robin Sequence</h2>
        <div id="roundRobinViz" class="flex items-center justify-center gap-4 p-6" style="min-height:200px;">
          <!-- Populated by JavaScript -->
        </div>
      </section>

      <!-- Pod Status Grid -->
      <section class="neon-border p-4">
        <h2 class="text-xl mb-3" style="color:#9bd5ff">Pod Status Grid</h2>
        <div id="podStatusGrid" class="grid sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
          <!-- Populated by JavaScript -->
        </div>
      </section>

      <!-- Request Distribution Chart -->
      <section class="neon-border p-4">
        <h2 class="text-xl mb-3" style="color:#9bd5ff">Request Distribution</h2>
        <canvas id="requestDistributionChart" class="w-full" style="height:300px; background:rgba(8,16,24,0.5);"></canvas>
      </section>

      <!-- Request Timeline -->
      <section class="neon-border p-4">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-xl" style="color:#9bd5ff">Request Timeline</h2>
          <span id="timelineCount" class="text-sm" style="color:#7aa8c7">0 requests</span>
        </div>
        <div id="requestTimeline" class="space-y-2 max-h-96 overflow-auto">
          <!-- Populated by JavaScript -->
        </div>
      </section>
    </div>
  </main>

  <!-- Help modal -->
  <div id="helpModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal-body neon-border">
      <h2 id="helpTitle" class="text-2xl" style="color:#9bd5ff">Perfect System (Tron)</h2>
      <p class="mt-2 text-sm" style="color:#cfe9ff">Declare <b>Desired</b>. The Controller reconciles <b>Actual</b> until they match.</p>
      <ul class="list-disc pl-5 text-sm mt-2" style="color:#9bd5ff">
        <li><b>Apply YAML:</b> sets Desired.</li>
        <li><b>Services/Pods:</b> shows Actual.</li>
        <li><b>Events:</b> tells you what happened (rollouts, health, scaling, chaos).</li>
        <li><b>Try this:</b> Play Demo (v1 → v2 → chaos).</li>
      </ul>
      <div class="mt-3 flex gap-2">
        <button id="playDemo2" class="neon-btn" style="color:#031b1a;background:linear-gradient(90deg,#00ffc6,#00e1ff);">▶ Play Demo</button>
        <button id="closeHelp" class="neon-btn" style="color:#9bd5ff">Close</button>
      </div>
    </div>
  </div>

<script>
const $ = (id)=>document.getElementById(id);
const connDot = $('connDot'); const connText = $('connText');
const yamlInput = $('yamlInput'); const servicesDiv=$('services'); const podsDiv=$('pods'); const eventsDiv=$('events');
const autoRefresh = $('autoRefresh'); const tourBtn=$('tourBtn'); const helpModal=$('helpModal');
const explainToggle=$('explainToggle'); const cpuRange=$('cpuRange'); const cpuVal=$('cpuVal');

// Tab navigation
const tabMain = $('tabMain');
const tabLoadBalancer = $('tabLoadBalancer');
const mainDashboardContent = $('mainDashboardContent');
const loadBalancerContent = $('loadBalancerContent');

// Load Balancer elements
const lbService = $('lbService');
const lbTestRequest = $('lbTestRequest');
const lbAutoTest = $('lbAutoTest');
const lbClearHistory = $('lbClearHistory');
const lbStats = $('lbStats');
const roundRobinViz = $('roundRobinViz');
const podStatusGrid = $('podStatusGrid');
const requestDistributionChart = $('requestDistributionChart');
const requestTimeline = $('requestTimeline');
const timelineCount = $('timelineCount');

const graphServiceSel = $('graphService');
const clearGraphsBtn = $('clearGraphs');
const chartReady = $('chartReady');
const chartRestarts = $('chartRestarts');
const chartCpu = $('chartCpu');

// Graph history: keep a short window of time series in the browser.
const GRAPH_RANGE_MS = 2 * 60 * 1000; // ~2 minutes
const graphHistory = {
  ready: {},
  desired: {},
  anoms: {},
  restarts: {},
  cpu: {},
};

// For a *real* "per minute" anomalies graph we keep a local buffer of WARN/ERROR
// event timestamps and compute a rolling 60s count.
const anomEventBuffer = {}; // svc -> [tsMs,...]
const anomSeenKeys = new Set();
const anomSeenQueue = []; // FIFO to cap memory
const MAX_SEEN_EVENT_KEYS = 5000;
let selectedGraphSvc = 'api';

let V1 = `apiVersion: v1
kind: Service
metadata: { name: api }
spec:
  image: local://demo@v1
  replicas: 3
  env:
    - { name: HEALTHY, value: "1" }
  readinessProbe:
    httpGet: { path: /healthz }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  livenessProbe:
    httpGet: { path: /livez }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  rollout:
    strategy: BlueGreen
`;
let V2 = `apiVersion: v1
kind: Service
metadata: { name: api }
spec:
  image: local://demo@v2
  replicas: 3
  env:
    - { name: HEALTHY, value: "1" }
  readinessProbe:
    httpGet: { path: /healthz }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  livenessProbe:
    httpGet: { path: /livez }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  rollout:
    strategy: BlueGreen
`;
let CAN = `apiVersion: v1
kind: Service
metadata: { name: api }
spec:
  image: local://demo@v2
  replicas: 4
  env:
    - { name: HEALTHY, value: "1" }
  readinessProbe:
    httpGet: { path: /healthz }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  livenessProbe:
    httpGet: { path: /livez }
    initialDelaySeconds: 1
    periodSeconds: 2
    failureThreshold: 3
  rollout:
    strategy: Canary
    steps:
      - { percent: 25 }
      - { percent: 50 }
      - { percent: 100 }
    pauseSeconds: 5
`;

yamlInput.value = V1;

cpuRange.addEventListener('input', ()=> cpuVal.textContent = cpuRange.value + '%');

function playClick(){ /* optional sfx; placeholder */ }

function row(html){ const d=document.createElement('div'); d.innerHTML=html; return d.firstElementChild; }

function cssVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function pushPoint(map, svc, t, v){
  map[svc] = map[svc] || [];
  const arr = map[svc];
  arr.push({ t, v });
  // Trim to time window (+ buffer)
  const cutoff = t - (GRAPH_RANGE_MS + 10_000);
  while (arr.length && arr[0].t < cutoff) arr.shift();
}

function recordAnomalyEvents(state){
  const evs = state?.events || [];
  for (const e of evs) {
    if (!e || !e.svc) continue;
    if (!(e.level === 'WARN' || e.level === 'ERROR')) continue;

    const tsMs = (typeof e.ts === 'number') ? e.ts : Date.parse(e.ts);
    if (!Number.isFinite(tsMs)) continue;

    // Best-effort de-dupe key (events don't have stable IDs in this project).
    const key = `${tsMs}|${e.level}|${e.svc}|${e.pod || ''}|${e.msg || ''}`;
    if (anomSeenKeys.has(key)) continue;
    anomSeenKeys.add(key);
    anomSeenQueue.push(key);
    if (anomSeenQueue.length > MAX_SEEN_EVENT_KEYS) {
      const old = anomSeenQueue.shift();
      if (old) anomSeenKeys.delete(old);
    }

    (anomEventBuffer[e.svc] = anomEventBuffer[e.svc] || []).push(tsMs);
  }

  // Prune buffers so they don't grow forever.
  const cutoff = Date.now() - (GRAPH_RANGE_MS + 60_000 + 10_000);
  for (const [svc, arr] of Object.entries(anomEventBuffer)) {
    while (arr.length && arr[0] < cutoff) arr.shift();
    if (!arr.length) delete anomEventBuffer[svc];
  }
}

function updateGraphServiceOptions(state){
  const names = Object.keys(state.services || {});
  if (!names.length) return;
  // If current selection disappeared, pick the first.
  if (!names.includes(selectedGraphSvc)) selectedGraphSvc = names[0];
  const cur = selectedGraphSvc;
  graphServiceSel.innerHTML = '';
  for (const n of names) {
    const opt = document.createElement('option');
    opt.value = n; opt.textContent = n;
    if (n === cur) opt.selected = true;
    graphServiceSel.appendChild(opt);
  }
}

function updateGraphHistory(state){
  const t = Date.now();
  recordAnomalyEvents(state);
  for (const [name, svc] of Object.entries(state.services || {})) {
    const desired = svc.replicas ?? 0;
    const ready = Object.values(state.pods || {}).filter(p=>p.service===name && p.ready).length;
    const restarts = (state.metrics?.restarts?.[name]) || 0;
    const cpu = svc.cpu || 0;

    // Anomalies / minute = rolling count of WARN/ERROR events observed in the last 60 seconds.
    const buf = anomEventBuffer[name] || [];
    const windowStart = t - 60_000;
    let anoms = 0;
    for (let i = buf.length - 1; i >= 0; i--) {
      if (buf[i] >= windowStart) anoms++;
      else break; // timestamps are appended in time order
    }

    pushPoint(graphHistory.desired, name, t, desired);
    pushPoint(graphHistory.ready, name, t, ready);
    pushPoint(graphHistory.anoms, name, t, anoms);
    pushPoint(graphHistory.restarts, name, t, restarts);
    pushPoint(graphHistory.cpu, name, t, cpu);
  }
}

function canvasBox(cnv){
  const ctx = cnv.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = cnv.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width));
  const h = Math.max(10, Math.floor(rect.height));
  if (cnv.width !== w * dpr || cnv.height !== h * dpr) {
    cnv.width = w * dpr;
    cnv.height = h * dpr;
  }
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, w, h };
}

function drawGrid(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = cssVar('--tron-grid') || 'rgba(0,255,255,0.08)';
  ctx.lineWidth = 1;
  const step = 40;
  for (let x=0; x<=w; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
  for (let y=0; y<=h; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  ctx.globalAlpha = 1;
}

function drawLine(ctx, points, xOf, yOf, stroke, dashed=false){
  if (!points || points.length < 2) return;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 2;
  ctx.setLineDash(dashed ? [6,4] : []);
  ctx.beginPath();
  for (let i=0;i<points.length;i++){
    const x = xOf(points[i]);
    const y = yOf(points[i]);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawText(ctx, txt, x, y, color){
  ctx.fillStyle = color;
  ctx.font = '12px Orbitron, ui-sans-serif, system-ui';
  ctx.fillText(txt, x, y);
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function drawTimeSeriesChart(cnv, seriesA, seriesB, opts){
  const { ctx, w, h } = canvasBox(cnv);
  drawGrid(ctx, w, h);

  const padL = 34, padR = 10, padT = 14, padB = 20;
  const left = padL, top = padT, right = w - padR, bottom = h - padB;

  const nowT = Date.now();
  const startT = nowT - GRAPH_RANGE_MS;
  const xOf = (p)=> left + ((p.t - startT) / GRAPH_RANGE_MS) * (right - left);

  const all = ([]).concat(seriesA||[], seriesB||[]).filter(p=>p.t >= startT);
  const vals = all.map(p=>p.v);
  let yMax = opts?.yMax != null ? opts.yMax : (Math.max(1, ...vals, 1));
  if (opts?.yMax == null) yMax = Math.max(1, Math.ceil(yMax * 1.25));
  const yOf = (p)=> bottom - (clamp(p.v, 0, yMax) / yMax) * (bottom - top);

  // Axis labels (0 and yMax)
  ctx.fillStyle = '#9db0c7';
  ctx.font = '10px ui-sans-serif, system-ui';
  ctx.fillText(String(yMax), 6, top+8);
  ctx.fillText('0', 14, bottom);
  ctx.globalAlpha = 0.6;
  ctx.strokeStyle = 'rgba(155,213,255,0.25)';
  ctx.beginPath(); ctx.moveTo(left, top); ctx.lineTo(left, bottom); ctx.lineTo(right, bottom); ctx.stroke();
  ctx.globalAlpha = 1;

  const good = cssVar('--tron-good') || '#00ff9d';
  const light = cssVar('--tron-light') || '#61e2ff';
  const warn = cssVar('--tron-warn') || '#ff9f43';

  drawLine(ctx, (seriesA||[]).filter(p=>p.t>=startT), xOf, yOf, opts?.colorA || good, false);
  if (seriesB) drawLine(ctx, (seriesB||[]).filter(p=>p.t>=startT), xOf, yOf, opts?.colorB || light, true);

  // Legend
  if (opts?.labelA) drawText(ctx, opts.labelA, left + 6, 12, opts?.colorA || good);
  if (opts?.labelB) drawText(ctx, opts.labelB, left + 120, 12, opts?.colorB || light);

  // Latest value
  const lastA = (seriesA||[]).slice(-1)[0];
  if (lastA) {
    const t = `${opts?.valuePrefix||''}${lastA.v}${opts?.valueSuffix||''}`;
    drawText(ctx, t, right - 70, 12, opts?.valueColor || warn);
  }
}

function computeRatePerMinuteFromCumulative(cumulativeSeries){
  const pts = cumulativeSeries || [];
  if (pts.length < 2) return [];
  const out = [];
  for (let i=1;i<pts.length;i++){
    const a = pts[i-1], b = pts[i];
    const dt = Math.max(0.001, (b.t - a.t) / 1000);
    const dv = Math.max(0, (b.v - a.v));
    const perMin = (dv / dt) * 60;
    out.push({ t: b.t, v: perMin });
  }
  return out;
}

function renderGraphs(){
  const svc = selectedGraphSvc;
  const ready = graphHistory.ready[svc] || [];
  const desired = graphHistory.desired[svc] || [];
  const anoms = graphHistory.anoms[svc] || [];
  const restarts = graphHistory.restarts[svc] || [];
  const cpu = graphHistory.cpu[svc] || [];

  drawTimeSeriesChart(chartReady, ready, desired, {
    labelA: 'Ready',
    labelB: 'Desired',
    valuePrefix: '',
  });

  drawTimeSeriesChart(chartRestarts, anoms, null, {
    labelA: 'WARN+ERROR/min',
    yMax: Math.max(1, Math.ceil(Math.max(1, ...(anoms.map(p=>p.v)||[1])) * 1.25)),
    valueSuffix: '/m',
  });

  drawTimeSeriesChart(chartCpu, cpu, null, {
    labelA: 'CPU %',
    yMax: 100,
    valueSuffix: '%',
  });
}

function render(state){
  // conn status
  connDot.style.color = '#00ff9d'; connText.textContent='Live';
  // services diff
  servicesDiv.innerHTML='';
  for (const [name, svc] of Object.entries(state.services)){
    const ready = Object.values(state.pods).filter(p=>p.service===name && p.ready).length;
    const desired = svc.replicas;
    const digestActual = (Object.values(state.pods).find(p=>p.service===name)?.image_digest)||'(none)';
    const diffHTML = `<div class="p-3 rounded border border-[#1b3a48] mb-2">
      <div class="flex items-center justify-between">
        <div class="text-[#cfe9ff]"><b>${name}</b></div>
        <div class="text-sm"><span style="color:#9bd5ff">Desired</span>: ${desired} · ${svc.digest} | <span style="color:#9bd5ff">Actual</span>: ${ready} · ${digestActual}</div>
      </div>
      <div class="mt-1 h-2 bg-[#0b1a24] rounded overflow-hidden">
        <div style="width:${Math.min(100, (ready/Math.max(1,desired))*100)}%; background:#00ff9d; height:100%"></div>
      </div>
    </div>`;
    servicesDiv.appendChild(row(diffHTML));
  }
  // pods
  podsDiv.innerHTML='';
  const pods = Object.values(state.pods).sort((a,b)=>a.start_ts-b.start_ts);
  for (const p of pods){
    // Determine pod health status
    const isHealthy = p.ready && p.phase === 'Running' && !p.terminating;
    const bgColor = isHealthy ? 'rgba(0, 255, 157, 0.1)' : 'rgba(255, 92, 122, 0.15)';
    const borderColor = isHealthy ? '#00ff9d' : '#ff5c7a';
    const statusText = isHealthy ? 'Ready' : (p.terminating ? 'Terminating' : (p.phase !== 'Running' ? 'Not Running' : 'Not Ready'));
    const statusColor = isHealthy ? '#00ff9d' : '#ff5c7a';
    const statusDot = isHealthy ? '●' : '○';
    
    podsDiv.appendChild(row(`<div class="p-3 rounded border-2 transition-all duration-300" style="background:${bgColor}; border-color:${borderColor};">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-2">
          <span style="color:${statusColor}; font-size: 12px;">${statusDot}</span>
          <div class="text-[#cfe9ff]"><b>${p.service}</b> · <span style="color:${statusColor}">${statusText}</span></div>
        </div>
        <div class="text-xs" style="color:#9bd5ff">digest ${p.image_digest} · ${p.id.slice(0,6)}</div>
      </div>
      <div class="text-xs mt-1" style="color:#7aa8c7">port ${p.port} · restarts ${p.restarts||0}</div>
    </div>`));
  }
  // events
  const filt = $('evtFilter').value;
  eventsDiv.innerHTML='';
  const evs = state.events.slice(-200).reverse();
  for (const e of evs){
    if (filt && !(e.msg.toLowerCase().includes(filt) || (e.explain||'').toLowerCase().includes(filt))) continue;
    const when = new Date(e.ts).toLocaleTimeString();
    const explain = (state.explain || $('explainToggle').checked) && e.explain ? ` — <span style="color:#9bd5ff">${e.explain}</span>` : '';
    eventsDiv.appendChild(row(`<div class="text-sm py-1 border-b border-[#142833]" style="color:#cfe9ff">
      <span style="color:#7aa8c7">${when}</span> [${e.level}] ${e.svc||'-'} ${e.pod||''}: ${e.msg}${explain}
    </div>`));
  }
  
  // Render metrics
  renderMetrics();

  // Graphs
  updateGraphServiceOptions(state);
  updateGraphHistory(state);
  renderGraphs();
  
  // Update load balancer service options
  updateLbServiceOptions(state);
  
  // Update load balancer dashboard if visible
  if (!loadBalancerContent.classList.contains('hidden')) {
    updateLoadBalancerDashboard();
  }
}

async function renderMetrics() {
  try {
    const resp = await fetch('/metrics', { headers: {'Accept': 'text/plain'} });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    console.log('[DEBUG] Metrics raw:', text.slice(0, 200)); // First 200 chars
    
    const metrics = parseMetrics(text);
    console.log('[DEBUG] Parsed metrics:', metrics);
    
    const metricsGrid = $('metricsGrid');
    metricsGrid.innerHTML = '';
    
    // Ready pods gauge
    const podsReady = metrics['api_pods_ready{service="api"}'] || 0;
    const podsDesired = metrics['api_pods_desired{service="api"}'] || 1;
    const readyPct = Math.round((podsReady / Math.max(1, podsDesired)) * 100);
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Ready Pods</div>
        <div class="gauge-value">${podsReady}/${podsDesired}</div>
        <div class="gauge-bar"><div class="gauge-fill" style="width: ${readyPct}%"></div></div>
        <div class="text-xs" style="color:#9bd5ff; margin-top: 4px;">${readyPct}%</div>
      </div>
    `));
    
    // Total restarts gauge
    const restarts = metrics['api_restarts_total{service="api"}'] || 0;
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Total Restarts</div>
        <div class="gauge-value">${restarts}</div>
        <div class="text-xs" style="color:#9db0c7; margin-top: 6px;">since start</div>
      </div>
    `));
    
    // INFO events counter
    const infoEvents = metrics['api_events_total{service="api",level="INFO"}'] || 0;
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Info Events</div>
        <div class="gauge-value">${infoEvents}</div>
        <div class="text-xs" style="color:#9db0c7; margin-top: 6px;">lifecycle</div>
      </div>
    `));
    
    // WARN events counter
    const warnEvents = metrics['api_events_total{service="api",level="WARN"}'] || 0;
    metricsGrid.appendChild(row(`
      <div class="gauge-card">
        <div class="gauge-label">Warn Events</div>
        <div class="gauge-value" style="color: #ff9f43;">${warnEvents}</div>
        <div class="text-xs" style="color:#9db0c7; margin-top: 6px;">anomalies</div>
      </div>
    `));
    
    console.log('[SUCCESS] Metrics rendered');
  } catch (e) {
    console.error('Metrics fetch failed:', e);
  }
}

function parseMetrics(text) {
  const lines = text.split('\n');
  const metrics = {};
  
  for (const line of lines) {
    if (line.startsWith('#') || !line.trim()) continue;
    
    // Parse: api_pods_ready{service="api"} 3
    const match = line.match(/^([\w_]+(?:\{[^}]+\})?)\s+([\d.]+)$/);
    if (match) {
      const [, key, value] = match;
      metrics[key] = parseFloat(value);
    }
  }
  
  return metrics;
}

graphServiceSel.addEventListener('change', ()=>{
  selectedGraphSvc = graphServiceSel.value;
  renderGraphs();
});
clearGraphsBtn.addEventListener('click', ()=>{
  for (const k of Object.keys(graphHistory)) graphHistory[k] = {};
  for (const k of Object.keys(anomEventBuffer)) delete anomEventBuffer[k];
  anomSeenKeys.clear();
  anomSeenQueue.length = 0;
  renderGraphs();
});
window.addEventListener('resize', ()=> {
  renderGraphs();
  if (!loadBalancerContent.classList.contains('hidden')) {
    updateRequestDistribution();
  }
});

async function fetchState(){ const r = await fetch('/state'); const s = await r.json(); render(s); }

// SSE live updates with reconnection
let eventSource = null;
let reconnectTimeout = null;

function connectSSE() {
  try {
    if (eventSource) {
      eventSource.close();
    }
    
    eventSource = new EventSource('/events');
    
    eventSource.onopen = () => {
      connDot.style.color = '#00ff9d';
      connText.textContent = 'Live';
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
    };
    
    eventSource.onmessage = (ev) => {
      try {
        const s = JSON.parse(ev.data);
        render(s);
        
        // Update load balancer dashboard if visible
        if (!loadBalancerContent.classList.contains('hidden')) {
          updatePodStatusGrid();
          updateStatsPanel();
        }
      } catch (err) {
        console.error('[SSE] Error parsing state:', err);
      }
    };
    
    eventSource.onerror = (err) => {
      connDot.style.color = '#ff5c7a';
      connText.textContent = 'Disconnected';
      
      if (eventSource.readyState === EventSource.CLOSED) {
        // Reconnect after delay
        if (!reconnectTimeout) {
          reconnectTimeout = setTimeout(() => {
            console.log('[SSE] Reconnecting...');
            connectSSE();
          }, 2000);
        }
      }
    };
  } catch (err) {
    console.error('[SSE] Connection error:', err);
    connDot.style.color = '#ff5c7a';
    connText.textContent = 'Error';
    
    // Retry connection
    if (!reconnectTimeout) {
      reconnectTimeout = setTimeout(() => {
        connectSSE();
      }, 3000);
    }
  }
}

// Initial connection
connectSSE();

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (eventSource) {
    eventSource.close();
  }
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout);
  }
});

async function applyYaml(y){ await fetch('/apply', { method:'POST', headers:{'Content-Type':'application/yaml'}, body:y }); playClick(); }
async function kill(service, count){ await fetch('/chaos/kill?service='+encodeURIComponent(service)+'&count='+count, { method:'POST' }); playClick(); }
async function scale(service, delta){ await fetch('/scale?service='+encodeURIComponent(service)+'&delta='+delta, { method:'POST' }); playClick(); }
async function setLoad(service, cpu){ await fetch('/load?service='+encodeURIComponent(service)+'&cpu='+cpu, { method:'POST' }); }

$('applyV1').onclick = ()=> applyYaml(V1);
$('applyV2').onclick = ()=> applyYaml(V2);
$('applyCanary').onclick = ()=> applyYaml(CAN);
$('applyYamlBtn').onclick = ()=> applyYaml(yamlInput.value);
$('scaleDown').onclick = ()=> scale('api', -1);
$('scaleUp').onclick = ()=> scale('api', 1);
$('copyCurl').onclick = ()=> {
  const cmd = `curl -X POST http://localhost:8080/apply -H 'Content-Type: application/yaml' --data-binary @- <<'YAML'\n${yamlInput.value}\nYAML`;
  navigator.clipboard.writeText(cmd);
};
document.addEventListener('keydown', (e)=> e.key==='y' && yamlInput.focus());

$('killOne').onclick = ()=> kill($('chaosService').value, 1);
$('killThree').onclick = ()=> kill($('chaosService').value, 3);
$('applyLoad').onclick = ()=> setLoad('api', parseInt(cpuRange.value,10));

// Guided tour
tourBtn.onclick = ()=> helpModal.classList.remove('hidden');
$('closeHelp').onclick = ()=> helpModal.classList.add('hidden');
$('playDemo2').onclick = ()=> playSequence();

$('playDemo').onclick = ()=> playSequence();
async function playSequence(){
  helpModal.classList.add('hidden');
  await applyYaml(V1);
  await sleep(3000);
  await applyYaml(V2);
  await sleep(4000);
  await applyYaml(CAN);
  await sleep(4000);
  await kill('api', 1);
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// Tab Navigation
function switchTab(tabName) {
  if (tabName === 'main') {
    tabMain.classList.add('active');
    tabMain.style.background = 'rgba(155,213,255,0.1)';
    tabLoadBalancer.classList.remove('active');
    tabLoadBalancer.style.background = 'transparent';
    mainDashboardContent.classList.remove('hidden');
    loadBalancerContent.classList.add('hidden');
  } else if (tabName === 'loadbalancer') {
    tabLoadBalancer.classList.add('active');
    tabLoadBalancer.style.background = 'rgba(155,213,255,0.1)';
    tabMain.classList.remove('active');
    tabMain.style.background = 'transparent';
    mainDashboardContent.classList.add('hidden');
    loadBalancerContent.classList.remove('hidden');
    updateLoadBalancerDashboard();
  }
}

tabMain.addEventListener('click', () => switchTab('main'));
tabLoadBalancer.addEventListener('click', () => switchTab('loadbalancer'));

// Load Balancer Data Structures
const requestHistory = [];
const podStats = {}; // podId -> { requestCount, lastRequest, port, service }

// Load Balancer Functions
function updateLbServiceOptions(state) {
  const names = Object.keys(state.services || {});
  if (names.length === 0) return;
  
  const current = lbService.value;
  lbService.innerHTML = '';
  for (const name of names) {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    if (name === current || (!current && name === 'api')) opt.selected = true;
    lbService.appendChild(opt);
  }
}

async function testLoadBalancerRequest() {
  const service = lbService.value;
  try {
    const resp = await fetch(`/lb/select?service=${encodeURIComponent(service)}`);
    const data = await resp.json();
    
    if (resp.ok && data.selected) {
      const selected = data.selected;
      const timestamp = Date.now();
      
      // Add to history
      requestHistory.unshift({
        timestamp,
        podId: selected.id,
        podPort: selected.port,
        service: service,
        success: true
      });
      
      // Limit history size
      if (requestHistory.length > 100) requestHistory.pop();
      
      // Update pod stats
      if (!podStats[selected.id]) {
        podStats[selected.id] = { requestCount: 0, lastRequest: 0, port: selected.port, service: service };
      }
      podStats[selected.id].requestCount++;
      podStats[selected.id].lastRequest = timestamp;
      
      // Update all visualizations
      updateRequestTimeline();
      setTimeout(() => updateRequestDistribution(), 10); // Small delay for canvas
      updateRoundRobinViz(data);
      updatePodStatusGrid();
      updateStatsPanel();
      
      return data;
    } else {
      console.error('Load balancer request failed:', data);
      return null;
    }
  } catch (err) {
    console.error('Load balancer error:', err);
    return null;
  }
}

async function autoTestLoadBalancer() {
  lbAutoTest.disabled = true;
  lbAutoTest.textContent = 'Running...';
  
  for (let i = 0; i < 10; i++) {
    await testLoadBalancerRequest();
    await new Promise(r => setTimeout(r, 500));
  }
  
  lbAutoTest.disabled = false;
  lbAutoTest.textContent = 'Auto Test (10x)';
}

function clearLoadBalancerHistory() {
  requestHistory.length = 0;
  Object.keys(podStats).forEach(key => {
    podStats[key].requestCount = 0;
  });
  updateRequestTimeline();
  updateRequestDistribution();
  updateStatsPanel();
  updatePodStatusGrid();
}

// Update Functions
function updateRequestTimeline() {
  timelineCount.textContent = `${requestHistory.length} requests`;
  
  if (requestHistory.length === 0) {
    requestTimeline.innerHTML = '<div class="text-sm text-center p-4" style="color:#7aa8c7">No requests yet. Click "Test Request" to start.</div>';
    return;
  }
  
  requestTimeline.innerHTML = requestHistory.slice(0, 50).map(req => {
    const time = new Date(req.timestamp).toLocaleTimeString();
    return `
      <div class="p-2 rounded border border-[#1b3a48] flex items-center justify-between" style="background:rgba(11,26,36,0.3);">
        <div class="flex items-center gap-3">
          <span class="text-xs" style="color:#7aa8c7">${time}</span>
          <span class="text-sm font-mono" style="color:#00ffc6">${req.podId}</span>
          <span class="text-xs" style="color:#9bd5ff">port ${req.podPort}</span>
        </div>
        <span class="text-xs" style="color:#00ff9d">✓</span>
      </div>
    `;
  }).join('');
}

function updateRequestDistribution() {
  const ctx = requestDistributionChart.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = requestDistributionChart.getBoundingClientRect();
  const w = Math.max(10, Math.floor(rect.width));
  const h = Math.max(10, Math.floor(rect.height));
  
  if (requestDistributionChart.width !== w * dpr || requestDistributionChart.height !== h * dpr) {
    requestDistributionChart.width = w * dpr;
    requestDistributionChart.height = h * dpr;
  }
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  
  ctx.clearRect(0, 0, w, h);
  
  // Get pod stats
  const pods = Object.entries(podStats).filter(([_, stats]) => stats.requestCount > 0);
  if (pods.length === 0) {
    ctx.fillStyle = '#7aa8c7';
    ctx.font = '16px Orbitron, ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('No requests yet', w / 2, h / 2);
    return;
  }
  
  const maxCount = Math.max(...pods.map(([_, stats]) => stats.requestCount));
  const barWidth = (w - 40) / pods.length;
  const barMaxHeight = h - 60;
  
  // Draw bars
  pods.forEach(([podId, stats], idx) => {
    const barHeight = (stats.requestCount / maxCount) * barMaxHeight;
    const x = 20 + idx * barWidth + barWidth / 2;
    const y = h - 40;
    
    // Bar
    ctx.fillStyle = '#00ffc6';
    ctx.fillRect(x - barWidth / 2 + 4, y - barHeight, barWidth - 8, barHeight);
    
    // Value
    ctx.fillStyle = '#cfe9ff';
    ctx.font = '12px Orbitron, ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(stats.requestCount.toString(), x, y - barHeight - 5);
    
    // Pod ID (truncated)
    ctx.fillStyle = '#9bd5ff';
    ctx.font = '10px ui-sans-serif, system-ui';
    ctx.fillText(podId.slice(0, 8), x, y + 15);
    ctx.fillText(`port ${stats.port}`, x, y + 28);
  });
  
  // Y-axis label
  ctx.fillStyle = '#9db0c7';
  ctx.font = '12px Orbitron, ui-sans-serif, system-ui';
  ctx.textAlign = 'left';
  ctx.fillText('Requests', 10, 20);
}

function updateRoundRobinViz(lbData) {
  if (!lbData || !lbData.healthyPods || lbData.healthyPods.length === 0) {
    roundRobinViz.innerHTML = '<div class="text-sm text-center" style="color:#7aa8c7">No healthy pods available</div>';
    return;
  }
  
  const selectedPodId = lbData.selected?.id;
  const pods = lbData.healthyPods;
  const currentIndex = pods.findIndex(p => p.id === selectedPodId);
  const nextIndex = (currentIndex + 1) % pods.length;
  
  roundRobinViz.innerHTML = pods.map((pod, idx) => {
    const isSelected = pod.id === selectedPodId;
    const isNext = idx === nextIndex;
    const borderColor = isSelected ? '#00ffc6' : (isNext ? '#9bd5ff' : '#1b3a48');
    const bgColor = isSelected ? 'rgba(0,255,198,0.15)' : (isNext ? 'rgba(155,213,255,0.1)' : 'rgba(11,26,36,0.3)');
    const borderWidth = isSelected ? '3px' : '1px';
    const selectedClass = isSelected ? 'selected-pod' : '';
    
    return `
      <div class="relative flex flex-col items-center p-4 rounded border-2 transition-all duration-300 ${selectedClass}" 
           style="border-color:${borderColor}; border-width:${borderWidth}; background:${bgColor}; min-width:120px;">
        ${isSelected ? '<div class="absolute -top-2 left-1/2 transform -translate-x-1/2 text-lg animate-pulse" style="color:#00ffc6;">▼</div>' : ''}
        ${isNext && !isSelected ? '<div class="absolute -top-2 left-1/2 transform -translate-x-1/2 text-xs" style="color:#9bd5ff;">→ Next</div>' : ''}
        <div class="text-sm font-mono mb-1 font-bold" style="color:${isSelected ? '#00ffc6' : '#cfe9ff'}">${pod.id.slice(0, 8)}</div>
        <div class="text-xs" style="color:#9bd5ff">Port ${pod.port}</div>
        <div class="text-xs mt-1" style="color:#7aa8c7">${podStats[pod.id]?.requestCount || 0} req</div>
      </div>
    `;
  }).join('');
}

function updatePodStatusGrid() {
  // Get current state
  fetch('/state').then(r => r.json()).then(state => {
    const service = lbService.value;
    const pods = Object.values(state.pods || {}).filter(p => !service || p.service === service);
    
    if (pods.length === 0) {
      podStatusGrid.innerHTML = '<div class="text-sm text-center p-4" style="color:#7aa8c7">No pods found</div>';
      return;
    }
    
    podStatusGrid.innerHTML = pods.map(pod => {
      const isHealthy = pod.ready && pod.phase === 'Running' && !pod.terminating;
      const stats = podStats[pod.id] || { requestCount: 0, lastRequest: 0 };
      const bgColor = isHealthy ? 'rgba(0,255,157,0.1)' : 'rgba(255,92,122,0.15)';
      const borderColor = isHealthy ? '#00ff9d' : '#ff5c7a';
      const statusText = isHealthy ? 'Healthy' : (pod.terminating ? 'Terminating' : 'Unhealthy');
      
      return `
        <div class="p-3 rounded border-2 transition-all" style="background:${bgColor}; border-color:${borderColor};">
          <div class="flex items-center justify-between mb-2">
            <div class="text-sm font-mono" style="color:#cfe9ff">${pod.id.slice(0, 10)}</div>
            <div class="text-xs px-2 py-1 rounded" style="background:${borderColor}; color:#031b1a">${statusText}</div>
          </div>
          <div class="text-xs mb-1" style="color:#9bd5ff">Port: ${pod.port}</div>
          <div class="text-xs mb-1" style="color:#9bd5ff">Service: ${pod.service}</div>
          <div class="text-xs mt-2 pt-2 border-t border-[#1b3a48]">
            <div style="color:#7aa8c7">Requests: <span style="color:#00ffc6">${stats.requestCount}</span></div>
            ${stats.lastRequest ? `<div style="color:#7aa8c7">Last: ${new Date(stats.lastRequest).toLocaleTimeString()}</div>` : ''}
          </div>
        </div>
      `;
    }).join('');
  }).catch(err => {
    console.error('Error updating pod status grid:', err);
  });
}

function updateStatsPanel() {
  const totalRequests = requestHistory.length;
  const pods = Object.entries(podStats).filter(([_, stats]) => stats.requestCount > 0);
  const avgRequests = pods.length > 0 ? (totalRequests / pods.length).toFixed(1) : 0;
  
  const requestCounts = pods.map(([_, stats]) => stats.requestCount);
  const maxRequests = requestCounts.length > 0 ? Math.max(...requestCounts) : 0;
  const minRequests = requestCounts.length > 0 ? Math.min(...requestCounts) : 0;
  
  // Calculate variance for distribution equality
  const variance = requestCounts.length > 0 
    ? requestCounts.reduce((sum, count) => sum + Math.pow(count - avgRequests, 2), 0) / requestCounts.length 
    : 0;
  const stdDev = Math.sqrt(variance).toFixed(1);
  
  // Get healthy pod count
  fetch('/state').then(r => r.json()).then(state => {
    const service = lbService.value;
    const allPods = Object.values(state.pods || {}).filter(p => !service || p.service === service);
    const healthyPods = allPods.filter(p => p.ready && p.phase === 'Running' && !p.terminating);
    
    lbStats.innerHTML = `
      <div class="p-3 rounded border border-[#1b3a48]" style="background:rgba(11,26,36,0.5);">
        <div class="text-xs mb-1" style="color:#7aa8c7">Total Requests</div>
        <div class="text-2xl font-bold" style="color:#00ffc6">${totalRequests}</div>
      </div>
      <div class="p-3 rounded border border-[#1b3a48]" style="background:rgba(11,26,36,0.5);">
        <div class="text-xs mb-1" style="color:#7aa8c7">Avg per Pod</div>
        <div class="text-2xl font-bold" style="color:#9bd5ff">${avgRequests}</div>
      </div>
      <div class="p-3 rounded border border-[#1b3a48]" style="background:rgba(11,26,36,0.5);">
        <div class="text-xs mb-1" style="color:#7aa8c7">Distribution (σ)</div>
        <div class="text-2xl font-bold" style="color:#ff9f43">${stdDev}</div>
        <div class="text-xs mt-1" style="color:#7aa8c7">Lower is better</div>
      </div>
      <div class="p-3 rounded border border-[#1b3a48]" style="background:rgba(11,26,36,0.5);">
        <div class="text-xs mb-1" style="color:#7aa8c7">Healthy Pods</div>
        <div class="text-2xl font-bold" style="color:#00ff9d">${healthyPods.length}</div>
        <div class="text-xs mt-1" style="color:#7aa8c7">of ${allPods.length} total</div>
      </div>
    `;
  }).catch(err => {
    console.error('Error updating stats panel:', err);
  });
}

function updateLoadBalancerDashboard() {
  updateRequestTimeline();
  updateRequestDistribution();
  updatePodStatusGrid();
  updateStatsPanel();
  
  // Get current LB state
  const service = lbService.value;
  fetch(`/lb/select?service=${encodeURIComponent(service)}`).then(r => r.json()).then(data => {
    if (data.selected) {
      updateRoundRobinViz(data);
    }
  }).catch(err => {
    console.error('Error updating load balancer dashboard:', err);
  });
}

// Event listeners
lbTestRequest.addEventListener('click', testLoadBalancerRequest);
lbAutoTest.addEventListener('click', autoTestLoadBalancer);
lbClearHistory.addEventListener('click', clearLoadBalancerHistory);

// polling
let timer = null;
autoRefresh.addEventListener('change', () => {
  if (autoRefresh.checked) timer = setInterval(fetchState, 1500);
  else { clearInterval(timer); timer = null; }
});
fetchState();
if (autoRefresh.checked) timer = setInterval(fetchState, 1500);
</script>
</body>
</html>
